.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GFF2BSML 1"
.TH GFF2BSML 1 "2010-10-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
gff32bsml.pl \- Convert GFF3 annotation data into BSML.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
gff32bsml.pl
         \-\-input=/path/to/annotation.gff3
         \-\-output=/path/to/results.bsml
         \-\-project=rca1
         \-\-id_repository=/usr/local/projects/rca1/workflow/project_id_repository
         \-\-organism='Aspergillus nidulans'
        [\-\-peptide_fasta=/path/to/peptide\-seqs.fsa
         \-\-peptide_id_regex='^>(\eS+)'
         \-\-peptide_id_prefix=''
         \-\-peptide_id_suffix='\-Protein'
         \-\-peptide_no_seqdata
         \-\-dna_fasta=/path/to/dna\-seqs.fsa
         \-\-dna_id_regex='^>(\eS+)'
         \-\-dna_id_prefix='Chr'
         \-\-dna_id_suffix=''
         \-\-dna_no_seqdata
         \-\-gene_type=gene
         \-\-organism_genetic_code=1
         \-\-organism_mt_genetic_code=4
         \-\-use_cds_parent_ids
         \-\-insert_missing_mrnas
         \-\-insert_missing_exons
         \-\-insert_polypeptides
         \-\-inserted_polypeptide_id_type=CDS
         \-\-default_seq_class=assembly
         \-\-default_seq_attributes='SO:contig'
         \-\-feat_attribute_mappings='Name:gene_product_name,comment:comment'
         \-\-clone_feat_attribute_mappings='gene:gene_product_name:transcript,gene:gene_product_name:CDS'
         \-\-feat_xref_mappings='ID:mydb:accession,Name:mydb:pub_locus'
         \-\-clone_feat_xref_mappings='gene:NCBILocus:transcript,gene:NCBILocus:CDS'
         \-\-seq_xref_mappings='ID:mydb:seq_id'
         \-\-atts_with_unescaped_commas='\s-1ID\s0,Name'
         \-\-allow_genes_with_no_cds
         \-\-sofa_type_mappings='transcript=>\s-1CDS\s0,ORF=>gene'
         \-\-log=/path/to/some.log
         \-\-debug=4
         \-\-help
         \-\-man ]
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fB\-\-input, \-g\fR
    path to the input \s-1GFF\s0 file.
.PP
\&\fB\-\-peptide_fasta, \-e\fR
    optional.  path to a multi-FASTA file containing the polypeptides for the genes in the \s-1GFF\s0 file.
    if this argument is supplied then the named file _must_ contain all the sequences for the 
    polypeptide/protein features in the input \s-1GFF\s0 file, _except_ those that appear in the ##FASTA
    section of the \s-1GFF\s0 file.
.PP
\&\fB\-\-peptide_id_regex\fR
    optional.  regular expression used to parse peptide unique id from \s-1FASTA\s0 deflines in \-\-peptide_fasta
    and the \s-1FASTA\s0 section of the \s-1GFF\s0 file itself.  in the latter case, the regular expression must \s-1NOT\s0
    match any non-peptide ids, otherwise \-\-peptide_id_prefix and \-\-peptide_id_suffix may be misapplied.
    default = ^>(\eS+)
.PP
\&\fB\-\-peptide_id_prefix\fR
    optional. prefix to prepend to the id parsed by \-\-peptide_id_regex to produce the polypeptide \s-1ID\s0 
    used by the corresponding \s-1GFF\s0 feature.
.PP
\&\fB\-\-peptide_id_suffix\fR
    optional. suffix to append to the id parsed by \-\-peptide_id_regex to produce the polypeptide \s-1ID\s0 
    used by the corresponding \s-1GFF\s0 feature.
.PP
\&\fB\-\-peptide_no_seqdata\fR
    do not create Seq-data or Seq-data-import entries for the polypeptide sequences; use \-\-peptide_fasta,
    if specified, only to determine the sequence length(s).
.PP
\&\fB\-\-dna_fasta\fR
    optional.  path to a multi-FASTA file containing the \s-1DNA\s0 sequences for the reference sequences
    in the \s-1GFF\s0 file.  if this argument is supplied then the named file _must_ contain all of the 
    sequences for the genomic sequence features in the input \s-1GFF\s0 file, _except_ those that appear
    in the ##FASTA section of the \s-1GFF\s0 file.
.PP
\&\fB\-\-dna_id_regex\fR
    optional.  regular expression used to parse the sequence unique id from \s-1FASTA\s0 deflines in 
    \-\-dna_fasta and the \s-1FASTA\s0 section of the \s-1GFF\s0 file itself.  in the latter case, the regular 
    expression must \s-1NOT\s0 match any non-peptide ids, otherwise \-\-dna_id_prefix and \-\-dna_id_suffix 
    may be misapplied..   default = ^>(\eS+)
.PP
\&\fB\-\-dna_id_prefix\fR
    optional. prefix to prepend to the id parsed by \-\-dna_id_regex to produce the sequence \s-1ID\s0 
    used by the corresponding \s-1GFF\s0 feature.
.PP
\&\fB\-\-dna_id_suffix\fR
    optional. suffix to append to the id parsed by \-\-dna_id_regex to produce the sequence \s-1ID\s0 
    used by the corresponding \s-1GFF\s0 feature.
.PP
\&\fB\-\-dna_no_seqdata\fR
    do not create Seq-data or Seq-data-import entries for the DNA/reference sequences; use \-\-dna_fasta,
    if specified, or the sequences present in the \s-1GFF\s0 file, only to determine the sequence length(s).
.PP
\&\fB\-\-gene_type\fR
    optional.  specifies a \s-1SO\s0 type in the input \s-1GFF\s0 file that should be replaced with \*(L"gene\*(R".  this can
    be used to handle nonstandard inputs in which, for example, the term \*(L"match\*(R" is used as the parent
    of one or more \s-1CDS\s0 features (e.g., as in GeneWise \s-1GFF\s0 output)  Note that the \s-1SO\s0 types _are_
    case\-sensitive.
.PP
\&\fB\-\-organism_genetic_code\fR
    optional.  specifies a genetic code value to appear in the \s-1BSML\s0 <Organism> element for \-\-organism
    see http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi?mode=c#SG1 for values
.PP
\&\fB\-\-organism_mt_genetic_code\fR
    optional.  specifies a mitochondrial genetic code value to appear in the \s-1BSML\s0 <Organism> element 
    for \-\-organism.  see http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi?mode=c#SG1 for values
.PP
\&\fB\-\-output, \-o\fR
    output \s-1BSML\s0 file (which should not exist before running the script.)
.PP
\&\fB\-\-project, \-p\fR
    project/database name used to create unique feature identifiers.
.PP
\&\fB\-\-id_repository, \-i\fR
    path to the Ergatis project_id_repository for the current project.
.PP
\&\fB\-\-organism, \-r\fR
    organism to place in the \s-1BSML\s0 <Genomes> section.  the first word will be used as the \s-1BSML\s0 genus,
    and the rest of the string will be placed in the \s-1BSML\s0 species attribute.
.PP
\&\fB\-\-use_cds_parent_ids,\-c\fR
    optional.  whether to use the \s-1GFF\s0 parent id to identify \s-1CDS\s0 features that lack an \s-1ID\s0 of their own.
.PP
\&\fB\-\-insert_missing_mrnas\fR
    optional.  automatically insert missing mRNA features wherever they are missing from the \s-1GFF\s0 
    (i.e., anytime a \s-1CDS\s0 feature is found hanging directly off a gene feature)
.PP
\&\fB\-\-insert_missing_exons\fR
    optional.  automatically inserts missing exon features in any gene model that does not have _any_
    exons but does have \s-1CDS\s0 features.  in this case a single exon will be created to exactly span each
    \s-1CDS\s0.
.PP
\&\fB\-\-insert_polypeptides\fR
    optional.  automatically inserts a polypeptide feature in any gene model that has one or more \s-1CDS\s0
    features but no polypeptide feature.
.PP
\&\fB\-\-inserted_polypeptide_id_type\fR
    optional. specifies which feature ('\s-1CDS\s0', 'gene', 'transcript', or 'mRNA') the newly-inserted
    polypeptide ids should be based on (default = 'gene')  the id of the new polypeptide will be 
    formed by taking the \s-1GFF\s0 id of the corresponding named feature and appending \*(L"\-Protein\*(R"  
    Note that \*(L"transcript\*(R" and \*(L"mRNA\*(R" are synonymous for the purposes of this option.
.PP
\&\fB\-\-default_seq_class,\-e\fR
    optional.  default sequence class/SO type (e.g., 'assembly', 'supercontig') to use for sequences 
    for which the type cannot be parsed from the \s-1GFF\s0 file.
.PP
\&\fB\-\-default_seq_attributes,\-e\fR
    optional.  comma-delimited list of \s-1BSML\s0 attributes (in colon-delimited key:value form) to associate
    with each genomic sequence in the \s-1GFF\s0 file.
.PP
\&\fB\-\-feat_attribute_mappings\fR
    optional.  a comma-delimited list of \s-1GFF\s0 attribute \-> \s-1BSML\s0 Attribute mappings, each of which is
    defined by a source (\s-1GFF\s0) attribute name and a target (\s-1BSML\s0) attribute name, separated by a colon,
    for example \*(L"Name:gene_product_name\*(R" will take each \s-1BSML\s0 'Name' value and insert it into the 
    \s-1BSML\s0 document as an <Attribute> with name=\*(L"Name\*(R" and content=the corresponding \s-1GFF\s0 attribute value.
    Any embedded colons may be escaped with a backslash (\*(L"\e:\*(R")
.PP
\&\fB\-\-clone_feat_attribute_mappings\fR
    optional.  a comma-delimited list of colon-separated values.  each member of the list is a colon\-
    separated triplet that contains 1. a source \s-1SOFA\s0 type, 2. a \s-1BSML\s0 attribute name, and 3. a target 
    \s-1SOFA\s0 type.  e.g., \*(L"gene:gene_product_name:CDS,gene:gene_product_name:transcript\*(R"  This particular
    example specifies that\*(--within each gene model/feature group\*(--any gene_product_name \s-1BSML\s0 Attributes
    attached to the gene feature will be copied over to the associated transcript and \s-1CDS\s0 features
    (without introducing duplicate attribute values).  This cloning/copying is done _after_ any applicable 
    \-\-feat_attribute_mappings have been processed for all of the involved features.
.PP
\&\fB\-\-feat_xref_mappings,\-x\fR
    optional.  a comma-delimited list of \s-1GFF\s0 attribute \-> \s-1BSML\s0 Cross-reference mappings, each of which
    is defined by a set of 3 values separated by colons, as in 'ID:mydb:accession', which specifies
    that each \s-1BSML\s0 '\s-1ID\s0' value should be inserted into the \s-1BSML\s0 document as a <Cross\-reference> 
    element with database=\*(L"mydb\*(R" and identifier\-type=\*(L"accession\*(R" (and identifier set to the \s-1ID\s0 value.)
    Any embedded colons may be escaped with a backslash (\*(L"\e:\*(R")
.PP
\&\fB\-\-clone_feat_xref_mappings\fR
    optional.  behaves similarly to \-\-clone_feat_attribute_mappings, but copying \s-1BSML\s0 <Cross\-references>
    instead of <Attributes>
.PP
\&\fB\-\-seq_xref_mappings\fR
    optional.  identical to \-\-xref_mappings except that it defines cross-reference mappings for the 
    reference _sequences_ in the \s-1GFF\s0 files (i.e., those things whose IDs appear in \s-1GFF\s0 column 1)
    in the case where the sequences are not themselves defined as \s-1GFF\s0 features the only attribute for
    which a mapping may be specified is '\s-1ID\s0'.
.PP
\&\fB\-\-atts_with_unescaped_commas\fR
    optional.  a comma-delimited list of \s-1GFF3\s0 attributes whose values (incorrectly) contain unescaped
    commas.  instead of parsing these values as comma-delimited lists the program will treat each as
    a single value and will parse it as though the commas embedded in the value had been correctly 
    URL\-escaped.
.PP
\&\fB\-\-allow_genes_with_no_cds\fR
    optional.  normally the script expects that any non-protein-coding gene will either: 1. be assigned
    an explicit \s-1SO\s0 type of 'pseudogene' instead of 'gene' or 2. have a non-coding \s-1RNA\s0 \s-1SO\s0 type at the
    transcript level (e.g., ncRNA, tRNA, etc.)  therefore if the script is running with \-\-insert_polypeptides
    and finds a gene for which neither of these things are true, it will fail with an error if the gene
    lacks a \s-1CDS\s0.  use this flag to permit the conversion to continue with a warning instead.
.PP
\&\fB\-\-sofa_type_mappings\fR
    optional.  a comma-delimited list of \s-1SOFA\s0 id or name mappings, in the form id1=>id2 or name1=>name2.
    each occurrence of id1 or name1 in the \s-1GFF3\s0 \s-1SOFA\s0 feature type column (\s-1GFF3\s0 column #3) will be
    replaced by id2/name2 prior to performing any subsequent parsing.  this option can be useful for
    making a \s-1GFF3\s0 file more closely match the canonical gene encoding.  for example, if a \s-1GFF3\s0 file
    uses the term \*(L"\s-1ORF\s0\*(R" instead of \*(L"gene\*(R" it can be rectified by specifying
    \-\-sofa_type_mappings='ORF=>gene'
.PP
\&\fB\-\-log,\-l\fR
    optional.  path to a log file the script should create.  will be overwritten if
    it already exists.
.PP
\&\fB\-\-debug,\-d\fR
    optional.  the debug level for the logger (an integer)
.PP
\&\fB\-\-help,\-h\fR
    print usage/help documentation
.PP
\&\fB\-\-man,\-m\fR
    print detailed usage/help documentation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This script parses a single \s-1GFF\s0 input file containing annotation data (for one or more
genomic sequences) and writes it out as a \s-1BSML\s0 document that can be subsequently fed 
into bsml2chado to load it into a Chado database.  This script was originally created 
by copying and then generalizing Brett Whitty's evmgff32bsml.pl utility.
.SH "INPUT"
.IX Header "INPUT"
A single \s-1GFF\s0 input file.  See the \s-1GFF\s0 documentation for more details.  Note that the
script has a number of options that allow it to correctly parse/convert a variety of
GFF-format files, even those that may deviate from the official specification in one
way or another.
.SH "OUTPUT"
.IX Header "OUTPUT"
A single \s-1BSML\s0 document.  See the \s-1BSML\s0 documentation for more details.
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 2
\&    Jonathan Crabtree
\&    jonathancrabtree@gmail.com
.Ve
