.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "JCVI::Translator::Base 3"
.TH JCVI::Translator::Base 3 "2010-10-22" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
JCVI::Translator::Base \- Contains translation methods for JCVI::Translator
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    my $base = new JCVI::Translator::Base;
\&    $base->set_seq($seq_ref);
\&    $base->set_partial($partial);
\&    $base->prepare($strand, $table);
\&    $base->endpoints($upper, $lower, $offset);
\&    my $pep_arrayref = $base->translate();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package contains the actual methods that do the translation.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.Sh "new"
.IX Subsection "new"
.SH "METHODS"
.IX Header "METHODS"
.Sh "clear"
.IX Subsection "clear"
Clear all stored variables
.Sh "set_seq"
.IX Subsection "set_seq"
Cache the seq_ref to be translated
.Sh "set_partial"
.IX Subsection "set_partial"
Set the partial status
.Sh "prepare"
.IX Subsection "prepare"
Prepare things related to the strand. Set up the increment, the rc boolean
value (stands for reverse complement \- false for + strand, true for \- strand),
and the translation tables that are being used.
.Sh "endpoints"
.IX Subsection "endpoints"
Set the endpoints for looping up. The translate method loops until the index is
equal to the stop endpoint. For this to work, the stop must be in the same
frame as the start. For the + strand, adjust the upper bound so that it is in
phase with lower bound and offset.
.PP
The \- strand is trickier. Not only adjust is the lower bound adjusted to be in
phase with the lower bound and offset, but 3 is also subtracted from the
bounds so that the right index for substring is present. Codons are indexed on
their lower bound, so 3 is subtracted to get from the upper end to the lower.
.PP
Below is an example that might make sense of this. Suppose we are interested in
translating the sequence \*(L"\s-1CAGTTTAACAAGTCGAAACCGTTC\s0\*(R" between positions 4 and 20:
.PP
.Vb 5
\&    Positions:             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
\&    Sequence                C A G T T T A A C A A G T C G A A A C C G T T C
\&    Region of interest (-): . . . .4- - - - - - - - - - - - - - - -20 . . .
\&    For + strand:                  4- - -|- - -|- - -|- - -|- - >19
\&    For - strand:              2. . .|< - -|- - -|- - -|- - -17 - -|
.Ve
.PP
For the + strand, endpoints will set the start to 4, and the stop to 19. This
grab the codon starting at base 4, 7, 10, 13 and 16 (at base 19, the index will
equal the stop, and the loop will terminate). Thus, we'll have the codons \s-1TTA\s0,
\&\s-1ACA\s0, \s-1AGT\s0, \s-1CGA\s0 and \s-1AAC\s0.
.PP
For a \- strand, start is 17 and stop is 2. This will get the codons starting at
17 (which ends at base 20), 14, 11, 8 and 5. It will not take the codon
starting at base 2, which is out of the specified bounds, because at that
point, the index will equal the stop and the loop will exit.
.Sh "translate"
.IX Subsection "translate"
Perform the actual translation. Try to translate the start codon if partial
isn't set, and then do the translation. Return the results as an arrayref.
.Sh "start"
.IX Subsection "start"
Translate the start codon if possible
.Sh "store_leftover"
.IX Subsection "store_leftover"
Store the leftover bases from translation. These are codons that have been cut
by splice sites.
.Sh "finish_leftover"
.IX Subsection "finish_leftover"
Extend the leftover to completion in the current codon, if possible.
.Sh "translate_leftover"
.IX Subsection "translate_leftover"
Translate the leftover codon. If partial isn't set, translate and then set the
partial flag.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kevin Galinsky, <kgalinsk@jcvi.org>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2008\-2009 J. Craig Venter Institute, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
